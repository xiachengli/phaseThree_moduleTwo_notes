#### zookeeper简介

```
zookeeper是一个开源的分布式协调服务。zookeeper是一个典型的分布式数据一致性的解决方案，分布式应用程序可以基于它实现诸如数据订阅/发布、负载均衡、命名服务、集群管理、分布式锁和分布式队列等功能
```

###### 基本概念

- 集群角色

  Leader：提供读写服务

  Follower：只读

  Observer：只读，不参与Leader选举投票，不参与写操作的过半写成功策略。因此observer可以在不影响写性能的情况下提升集群的性能

- 会话session

  session指客户端会话，一个客户端连接是指客户端和服务端之间的一个TCP长连接，客户端通过心跳检测与服务器保持有效的会话

- 数据节点

  数据模型中的数据单元，称之为数据节点。zookeeper将所有的数据存储在内存中，数据模型是一棵树，由斜杆进行分割的路径，就是一个znode。每个znode上都会保存自己的数据内容，同时还会保存一系列属性信息

- 版本

  对于每个znode，zookeeper都会为其维护一个叫做stat的数据结构，stat记录了这个znode的三个数据版本，分别是version（当前znode版本）、cversion(当前znode子节点的版本)、aversion(当前znode的ACL版本)

- watcher(事件监听器)

  允许用户在指定节点上注册一些watcher，并且在一些特定事件触发的时候，zookeeper服务端会将事件通知到感兴趣的客户端

- ACL

  zookeeper采用ACL（access controller lists）策略来进行权限控制，其定义了如下5种权限：

  create：创建子节点的权限

  read：获取节点数据和子节点列表的权限

  write：更新节点数据的权限

  delete：删除子节点的权限

  admin：设置节点ACL的权限

  注：create和delete都是针对子节点的权限控制

#### zookeeper环境搭建

- 单机模式：只运行在一台服务器上
- 集群模式：运行在一个集群上
- 伪集群模式：一台服务器上运行多个zookeeper实例

#### zookeeper基本使用

###### 系统模型

```
zookeeper数据模型znode
	在zookeeper种，数据被保存在一个个数据节点上，这些节点被称为znode。znode的节点路径标识方式和unix文件系统路径非常相似，都是由一系列使用斜杆（/）进行分割的路径表示
	
znode的类型
	持久节点：指节点被创建后会一直存在服务器上，直至被主动删除
	持久顺序节点：有顺序的持久节点，在创建节点的时候，会在节点名后面加一个数字后缀来表示其顺序
	临时节点：它的生命周期和客户端的会话绑在一起，客户端会话结束，节点会被删除掉。与持久性节点不同的是，临时节点不能创建子节点
	临时顺序节点：有顺序的临时节点
```

```
事务ID
	在zookeeper中，事务指能够改变zookeeper服务器状态的操作（节点创建、删除、更新）。对于每一个事务请求，zookeeper都会为其分配一个全局唯一的事务ID，用ZXID表示，通常是一个64位的数字。每一个ZXID对应一次更新操作
```

```
znode状态信息：节点数据内容和节点状态西信息
	czxid：节点被创建时的事务ID
	ctime：节点创建时间
	mzxid：节点最后一次被修改的时间
	pzxid：子节点列表最后一次被修改时的事务ID
	cversion：子节点的版本号
	dataVersion：内容版本号
	aclVersion：ACL版本
	ephemeralOwner：创建临时节点时的会话sessionID，如果是持久性节点那么值为0
	dataLength：数据长度
	numChildren：直系子节点数
```

```
watcher数据变更通知
	客户端向服务器注册一个watch监听，当服务端的一些指定事件触发了这个watcher，那么就会向指定客户端发送一个事件通知来实现分布式的通知功能
	
	watcher机制主要包括客户端线程、客户端watcherManager、zookeeper服务器三部分。具体工作流程为：客户端向zookeeper服务器注册的同时，会将watcher对象存储在客户端的watcherManager中，当服务器触发watcher事件后，会向客户端发送通知，客户端线程从watcherManager中取出对应的watcher对象来执行回调逻辑
```

```
ACL保障数据的安全
	通常使用"scheme:id:permission"来标识一个有效的ACL信息
	scheme权限模式：用来确定权限验证过程中使用的校验策略，有如下四种模式
		IP：根据IP地址来进行权限控制
		Digest：使用"username:password"形式的权限来进行权限配置，当使用"username:password"形式配置了权限标识后，zookeeper会先后对其进行SHA-1加密和BASE64编码
		World：数据节点的访问权限对所有用户开放。world模式也可以看作是一种特殊的Digest模式，它只有一个权限标识，即"world:anyone"
		Super：超级用户，也是一种特殊的Digest模式。在super模式下，超级用户可以对任意zookeeper上的数据节点进行任何操作
		
	id授权对象：指的是权限赋予的用户或一个指定实体。在不同的权限模式下，授权对象是不同的
	
	permission权限：指通过权限检查后可以被允许执行的操作
```



###### 命令行操作

```
创建节点：create [-s][-e] path data acl
列出指定节点下的所有的一级子节点：ls path
读取节点(数据内容和属性信息)：get path
更新节点：set path data [version]
删除节点：delete path [version]
```



#### zookeeper应用场景

###### 数据发布/订阅

```
发布者将数据发布到zookeeper的一个或一系列节点上，订阅者进行数据订阅，从而达到动态获取数据的目的，实现配置信息的集中式管理和数据的动态更新

发布/订阅系统一般有两种设计模式：推模式和拉模式
推模式：服务端主动将数据更新发送给所有订阅的客户端
拉模式：客户端主动发起请求来获取最新数据，通常采用定时进行轮询的方式

zookeeper采用推拉相结合的方式：客户端向服务端注册自己需要关注的节点，一旦该节点的数据发生变更，那么服务端就会向相应的客户端发送watcher事件通知，客户端接收到消息通知后，需要主动到服务端获取最新的数据
```

###### 命名服务

```
命名服务功能能够帮助应用系统通过一个资源引用的方式来实现对资源的定位与使用。在分布式系统中，被命名的的实体可以是集群中的机器、提供的服务地址或远程对象等
```

###### 集群管理

```
集群管理，包括集群监控与集群控制两大块，前者侧重对集群运行时状态的收集，后者则是对集群进行操作与控制
```

###### 分布式锁

```
控制分布式系统中之间同步访问共享资源的一种方式
```

#### zookeeper深入进阶

###### ZAB协议

```
Zookeeper Atomic Broadcast原子消息广播协议
ZAB协议并不像Paxos算法那样是一种通用的分布式一致性算法，它是一种特别为zookeeper专门设计的一种支持崩溃恢复的原子广播协议。基于该协议，zookeeper实现了一种主备模式的系统架构来保持集群中各副本之间的数据一致性。实现原理就是使用一个单一的主进程来接收并处理客户端的所有事务请求，并采用ZAB的原子广播协议，将服务器数据的状态变更以事务Proposal的形式广播到所有的副本进程中，ZAB协议的主备模式保证了同一时刻集群中只存在一个主进程来广播服务器的状态变更，因此能够很好的处理客户端大量的并发请求


```

```
ZAB协议包括两种基本的模式：崩溃恢复和消息广播
	当leader服务器出现网络中断、崩溃退出或重启等异常情况时，ZAB协议就会进入崩溃恢复模式，同时选举产生新的leader服务器。当选举产生了新的leader服务器且集群中过半机器与该leader完成了状态同步之后，ZAB协议就会退出恢复模式
	当集群中已经有过半的Follower服务器与leader服务器完成了状态同步，那么整个服务框架就可以进入消息广播模式
```



注：这张理论性东西太多了，且耗时已久，所以笔记先暂时这样吧